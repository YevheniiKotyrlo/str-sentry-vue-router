diff --git a/node_modules/@sentry/vue/build/esm/router.js b/node_modules/@sentry/vue/build/esm/router.js
--- a/node_modules/@sentry/vue/build/esm/router.js
+++ b/node_modules/@sentry/vue/build/esm/router.js
@@ -15,10 +15,12 @@ function instrumentVueRouter(
   startNavigationSpanFn,
 ) {
   let hasHandledFirstPageLoad = false;
+  const isLegacyRouter = 'mode' in router;
+  console.log('[sentry-patch] isLegacyRouter:', isLegacyRouter);

   router.onError(error => captureException(error, { mechanism: { handled: false } }));

-  router.beforeEach((to, _from, next) => {
+  router.beforeEach((to, _from, ...rest) => {
     // We avoid trying to re-fetch the page load span when we know we already handled it the first time
     const activePageLoadSpan = !hasHandledFirstPageLoad ? getActivePageLoadSpan() : undefined;

@@ -80,11 +82,13 @@ function instrumentVueRouter(
       });
     }

-    // Vue Router 4 no longer exposes the `next` function, so we need to
-    // check if it's available before calling it.
-    // `next` needs to be called in Vue Router 3 so that the hook is resolved.
-    if (next) {
-      next();
+    console.log('[sentry-patch] beforeEach guard called for:', to.path, '| isLegacyRouter:', isLegacyRouter, '| rest args:', rest.length);
+    if (isLegacyRouter) {
+      const next = rest[0];
+      if (typeof next === 'function') {
+        console.log('[sentry-patch] calling next() for legacy router');
+        next();
+      }
     }
   });
 }
